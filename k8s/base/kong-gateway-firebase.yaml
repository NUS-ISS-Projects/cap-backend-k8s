apiVersion: apps/v1
kind: Deployment
metadata:
  name: kong-gateway
  labels:
    app: kong-gateway
spec:
  replicas: 1
  selector:
    matchLabels:
      app: kong-gateway
  template:
    metadata:
      labels:
        app: kong-gateway
    spec:
      initContainers:
      - name: install-firebase-plugin
        image: alpine:3.18
        command: ["/bin/sh"]
        args:
          - -c
          - |
            # Install dependencies
            apk add --no-cache curl
            
            # Create proper Kong plugin directory structure
            mkdir -p /kong-plugins/kong/plugins/jwt-firebase
            
            # Create a simple Firebase JWT plugin
            cat > /kong-plugins/kong/plugins/jwt-firebase/handler.lua << 'EOF'
            local http = require "resty.http"
            local cjson = require "cjson"
            local jwt_decoder = require "kong.plugins.jwt.jwt_parser"
            local openssl_digest = require "resty.openssl.digest"
            local openssl_pkey = require "resty.openssl.pkey"
            
            local FirebaseJWTHandler = {
              PRIORITY = 1000,
              VERSION = "1.0.0",
            }
            
            local function fetch_firebase_keys()
              local httpc = http.new()
              local res, err = httpc:request_uri("https://www.googleapis.com/robot/v1/metadata/x509/securetoken@system.gserviceaccount.com")
              
              if not res then
                kong.log.err("Failed to fetch Firebase keys: ", err)
                return nil
              end
              
              if res.status ~= 200 then
                kong.log.err("Firebase keys request failed with status: ", res.status)
                return nil
              end
              
              local keys = cjson.decode(res.body)
              return keys
            end
            
            local function verify_firebase_jwt(token, firebase_keys, firebase_project_id)
              kong.log.notice("[DEBUG] Starting JWT verification for token length: ", string.len(token))
              
              -- Parse JWT without consumer validation
              local jwt_token = jwt_decoder:new(token)
              if not jwt_token then
                kong.log.err("[DEBUG] JWT decoder failed to parse token")
                return nil, "Invalid JWT format"
              end
              kong.log.notice("[DEBUG] JWT token parsed successfully")
              
              -- Get key ID from header
              local kid = jwt_token.header.kid
              kong.log.notice("[DEBUG] Key ID from header: ", kid or "nil")
              if not kid or not firebase_keys[kid] then
                kong.log.err("[DEBUG] Invalid key ID or key not found: ", kid or "nil")
                -- Log available keys for debugging
                kong.log.notice("[DEBUG] Available Firebase keys:")
                for k, v in pairs(firebase_keys) do
                  kong.log.notice("[DEBUG]   Key ID: ", k, " (length: ", string.len(v), ")")
                end
                return nil, "Invalid key ID"
              end
              
              -- Load Firebase public key from X.509 certificate
              local cert_data = firebase_keys[kid]
              kong.log.notice("[DEBUG] Loading X.509 certificate (length: ", string.len(cert_data), ")")
              local x509 = require "resty.openssl.x509"
              local cert, err = x509.new(cert_data)
              if not cert then
                kong.log.err("[DEBUG] Failed to load Firebase certificate: ", err or "unknown error")
                return nil, "Failed to load Firebase certificate: " .. (err or "unknown error")
              end
              kong.log.notice("[DEBUG] X.509 certificate loaded successfully")
              
              -- Extract public key from certificate
              local pkey = cert:get_pubkey()
              if not pkey then
                kong.log.err("[DEBUG] Failed to extract public key from certificate")
                return nil, "Failed to extract public key from certificate"
              end
              kong.log.notice("[DEBUG] Public key extracted successfully")
              
              -- Verify signature manually using OpenSSL
               local header_b64, payload_b64, signature_b64 = token:match("([^%.]+)%.([^%.]+)%.([^%.]+)")
               if not header_b64 or not payload_b64 or not signature_b64 then
                 kong.log.err("[DEBUG] Failed to split JWT into 3 parts")
                 return nil, "Invalid JWT format"
               end
              kong.log.notice("[DEBUG] JWT split successfully - Header: ", string.len(header_b64), ", Payload: ", string.len(payload_b64), ", Signature: ", string.len(signature_b64))
              
              -- Create signing input
              local signing_input = header_b64 .. "." .. payload_b64
              kong.log.notice("[DEBUG] Signing input created (length: ", string.len(signing_input), ")")
              
              -- Decode signature
              local ngx_base64 = require "ngx.base64"
              local signature = ngx_base64.decode_base64url(signature_b64)
              if not signature then
                kong.log.err("[DEBUG] Failed to decode base64url signature")
                return nil, "Invalid signature encoding"
              end
              kong.log.notice("[DEBUG] Signature decoded successfully (length: ", string.len(signature), ")")
              
              -- Verify signature with RS256 (PKCS#1 v1.5 padding)
               local digest = require "resty.openssl.digest"
               
               -- Create SHA256 hash of the signing input
               kong.log.notice("[DEBUG] Creating SHA256 hash of signing input")
               local sha256 = digest.new("sha256")
               sha256:update(signing_input)
               local hash = sha256:final()
               kong.log.notice("[DEBUG] SHA256 hash created (length: ", string.len(hash), ")")
               
               -- Try multiple verification approaches
               kong.log.notice("[DEBUG] Attempting signature verification with RSA-SHA256")
               
               -- Method 1: Try with string algorithm specification
               local verified, err = pkey:verify(signature, hash, "sha256")
               kong.log.notice("[DEBUG] Method 1 (sha256 string) result: ", verified and "SUCCESS" or "FAILED", ", Error: ", err or "none")
               
               if not verified then
                 -- Method 2: Try with raw signature verification and string algorithm
                 kong.log.notice("[DEBUG] Trying method 2: raw signature verification with sha256")
                 verified, err = pkey:verify(signature, signing_input, "sha256")
                 kong.log.notice("[DEBUG] Method 2 (raw input + sha256) result: ", verified and "SUCCESS" or "FAILED", ", Error: ", err or "none")
               end
               
               if not verified then
                 -- Method 3: Try without explicit parameters (default)
                 kong.log.notice("[DEBUG] Trying method 3: default parameters")
                 verified, err = pkey:verify(signature, hash)
                 kong.log.notice("[DEBUG] Method 3 (default) result: ", verified and "SUCCESS" or "FAILED", ", Error: ", err or "none")
               end
              
              if not verified then
                kong.log.err("[DEBUG] JWT signature verification failed: ", err or "unknown error")
                kong.log.err("[DEBUG] Signature (base64): ", ngx.encode_base64(signature))
                kong.log.err("[DEBUG] Hash (base64): ", ngx.encode_base64(hash))
                return nil, "Invalid JWT signature"
              end
              
              kong.log.notice("[DEBUG] JWT signature verification successful!")
              
              -- Verify Firebase-specific claims
              local payload = jwt_token.claims
              if payload.iss ~= "https://securetoken.google.com/" .. firebase_project_id then
                return nil, "Invalid issuer"
              end
              
              if payload.aud ~= firebase_project_id then
                return nil, "Invalid audience"
              end
              
              -- Verify expiration
              local now = ngx.time()
              if payload.exp and payload.exp < now then
                return nil, "Token expired"
              end
              
              return payload
            end
            
            function FirebaseJWTHandler:access(conf)
              local token = kong.request.get_header("authorization")
              if not token then
                return kong.response.exit(401, {message = "Missing authorization header"})
              end
              
              token = token:match("Bearer%s+(.+)")
              if not token then
                return kong.response.exit(401, {message = "Invalid authorization header format"})
              end
              
              local keys = fetch_firebase_keys()
              if not keys then
                return kong.response.exit(500, {message = "Failed to fetch Firebase keys"})
              end
              
              -- Verify Firebase JWT
              kong.log.notice("[DEBUG] Starting Firebase JWT verification for token: ", string.sub(token, 1, 50), "...")
              local payload, err = verify_firebase_jwt(token, keys, conf.firebase_project_id)
              if not payload then
                kong.log.err("[DEBUG] JWT verification failed: ", err or "unknown error")
                return kong.response.exit(401, {message = err or "JWT verification failed"})
              end
              
              kong.log.notice("[DEBUG] JWT verification successful! Payload received")
              kong.log.notice("[DEBUG] User ID (sub): ", payload.sub or "nil")
              kong.log.notice("[DEBUG] User Email: ", payload.email or "nil")
              kong.log.notice("[DEBUG] Issuer: ", payload.iss or "nil")
              kong.log.notice("[DEBUG] Audience: ", payload.aud or "nil")
              kong.log.notice("[DEBUG] Expiration: ", payload.exp or "nil")
              
              -- Create or find Kong consumer based on Firebase user ID
              local consumer_id = "firebase_" .. (payload.sub or "unknown")
              kong.log.notice("[DEBUG] Setting Kong consumer ID: ", consumer_id)
              
              -- Set Kong consumer context
              local consumer = {
                id = consumer_id,
                username = payload.email or consumer_id,
                custom_id = payload.sub
              }
              kong.log.notice("[DEBUG] Created Kong consumer: ", consumer.username)
              
              -- Set the authenticated consumer in Kong context
              kong.client.authenticate(consumer, nil)
              kong.log.notice("[DEBUG] Kong consumer authenticated successfully")
              
              -- Set user info in headers for downstream services
              kong.service.request.set_header("X-User-ID", payload.sub)
              kong.service.request.set_header("X-Consumer-ID", consumer_id)
              if payload.email then
                kong.service.request.set_header("X-User-Email", payload.email)
              end
              
              -- Forward the original Authorization header to downstream service
              kong.service.request.set_header("Authorization", "Bearer " .. token)
              kong.log.notice("[DEBUG] Authorization header forwarded to downstream service")
              kong.log.notice("[DEBUG] User headers set for downstream services")
            end
            
            return FirebaseJWTHandler
            EOF
            
            # Create schema file
            cat > /kong-plugins/kong/plugins/jwt-firebase/schema.lua << 'EOF'
            return {
              name = "jwt-firebase",
              fields = {
                { config = {
                    type = "record",
                    fields = {
                      { firebase_project_id = { type = "string", required = false } },
                    },
                  },
                },
              },
            }
            EOF
            
            # Verify plugin structure
            echo "Firebase JWT plugin created successfully"
            find /kong-plugins -name "*.lua" -type f
            ls -la /kong-plugins/kong/plugins/jwt-firebase/
        volumeMounts:
        - name: kong-plugins
          mountPath: /kong-plugins
      containers:
      - name: kong
        image: kong:3.4
        env:
        - name: KONG_DATABASE
          value: "off"
        - name: KONG_DECLARATIVE_CONFIG
          value: "/kong/declarative/kong.yml"
        - name: KONG_PROXY_ACCESS_LOG
          value: "/dev/stdout"
        - name: KONG_ADMIN_ACCESS_LOG
          value: "/dev/stdout"
        - name: KONG_PROXY_ERROR_LOG
          value: "/dev/stderr"
        - name: KONG_ADMIN_ERROR_LOG
          value: "/dev/stderr"
        - name: KONG_ADMIN_LISTEN
          value: "0.0.0.0:8001"
        - name: KONG_PLUGINS
          value: "bundled,jwt-firebase"
        - name: KONG_LUA_PACKAGE_PATH
          value: "/kong-plugins/?.lua;/kong-plugins/?/init.lua;;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua"
        ports:
        - containerPort: 8000
          name: proxy
        - containerPort: 8001
          name: admin
        volumeMounts:
        - name: kong-config
          mountPath: /kong/declarative
        - name: kong-plugins
          mountPath: /kong-plugins
        readinessProbe:
          httpGet:
            path: /status
            port: 8001
          initialDelaySeconds: 30
          periodSeconds: 10
        livenessProbe:
          httpGet:
            path: /status
            port: 8001
          initialDelaySeconds: 60
          periodSeconds: 30
      volumes:
      - name: kong-config
        configMap:
          name: kong-config-firebase
      - name: kong-plugins
        emptyDir: {}
---
apiVersion: v1
kind: Service
metadata:
  name: kong-gateway-service
spec:
  selector:
    app: kong-gateway
  ports:
  - name: proxy
    port: 8000
    targetPort: 8000
    nodePort: 32080
  - name: admin
    port: 8001
    targetPort: 8001
    nodePort: 32081
  type: NodePort
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: kong-config-firebase
data:
  kong.yml: |
    _format_version: "3.0"
    _transform: true

    services:
    # Data Ingestion Service
    - name: data-ingestion-service
      url: http://data-ingestion-service:8080
      routes:
      # Health endpoint - NO authentication
      - name: data-ingestion-health
        paths:
        - /api/ingestion/health
        strip_path: false
      # All other ingestion endpoints - WITH authentication
      - name: data-ingestion-protected
        paths:
        - /api/ingestion
        strip_path: false
        plugins:
        - name: jwt-firebase
          config:
            firebase_project_id: "cap-backend-user"
        
    # Data Processing Service
    - name: data-processing-service
      url: http://data-processing-service:8080
      routes:
      # Health endpoint - NO authentication
      - name: data-processing-health
        paths:
        - /api/processing/health
        strip_path: false
      # All other processing endpoints - WITH authentication
      - name: data-processing-protected
        paths:
        - /api/processing
        strip_path: false
        plugins:
        - name: jwt-firebase
          config:
            firebase_project_id: "cap-backend-user"
        
    # Data Acquisition Service
    - name: data-acquisition-service
      url: http://data-acquisition-service:8080
      routes:
      # Health endpoint - NO authentication
      - name: data-acquisition-health
        paths:
        - /api/acquisition/health
        strip_path: false
      # All other acquisition endpoints - WITH authentication
      - name: data-acquisition-protected
        paths:
        - /api/acquisition
        strip_path: false
        plugins:
        - name: jwt-firebase
          config:
            firebase_project_id: "cap-backend-user"
        
    # User Service
    - name: cap-user-service
      url: http://cap-user-service:8080
      routes:
      # Health endpoint - NO authentication
      - name: user-health
        paths:
        - /api/user/health
        strip_path: false
      # Public auth endpoints - NO authentication
      - name: user-auth-public
        paths:
        - /api/auth/login
        - /api/auth/register
        strip_path: false
      # Protected user endpoints - WITH authentication
      - name: user-protected
        paths:
        - /api/users
        - /api/user-sessions
        strip_path: false
        plugins:
        - name: jwt-firebase
          config:
            firebase_project_id: "cap-backend-user"

    # No consumers needed - Firebase JWT plugin handles verification directly
    consumers: []